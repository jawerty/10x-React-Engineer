# -*- coding: utf-8 -*-
"""10x-React-Engineer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10Rr7ucLdPyMhQ3lmfNtdreHV-NTMIjQB
"""

import locale
import transformers
import torch
import os
import re
from transformers import AutoTokenizer

import prompt.py

locale.getpreferredencoding = lambda: "UTF-8"

!pip install -U accelerate

!pip install transformers

!huggingface-cli login

# model = "meta-llama/Llama-2-13b-chat-hf"
model = "meta-llama/Llama-2-70b-chat-hf"

tokenizer = AutoTokenizer.from_pretrained(model)
pipeline = transformers.pipeline(
    "text-generation",
    model=model,
    torch_dtype=torch.float16,
    device_map="auto",
)

"""
  How our 10x React Engineer will code
  - We need to ask the user what
    - What is the design library?
  - We need to figure out if we need to build the backend
    - Load an express app in a single file
  - After we render
"""

# this function generates text using the Llama 2 model based on the given prompt
# returns the generated text
def generate(prompt):
  sequences = pipeline(
      prompt,
      do_sample = True,
      top_k = 10,
      num_return_sequences = 1,
      eos_token_id = tokenizer.eos_token_id,
      max_length = 10000,
  )
  return sequences[0]['generated_text']

# this function parses the summarization result from the output string
# returns the summarized text
def parse_summarization_result(output):
  label_token = 'Label:'
  output_lines = output.split("\n")
  for i in reversed(range(0, len(output_lines))):
    if label_token in output_lines[i]:
      return output_lines[i][len(label_token):].strip()

# this function parses the scaffolding result from the output string
# returns a list of dictionaries containing the file name and code block for each file
def parse_scaffolding_result(output):
  output = output[output.index("[/INST]"):]
  code_blocks = re.findall(r"```(.*?)```", output, re.DOTALL)
  file_names = re.findall(r"\*\*(.*?)\*\*", output, re.DOTALL)
  print(file_names)
  print(code_blocks)
  code_files = []
  print("files length", len(file_names))
  print("codes length", len(code_blocks))

  for i in range(0, len(file_names)):
    if i < len(code_blocks):
      code_files.append({
          "file_name": file_names[i],
          "code_block": code_blocks[i]
      })

  return code_files

# this function takes a list of code files and a modification prompt and generates a new code block for each file using the prompt
# returns a list of dictionaries containing the file name and code block for each file
def initiate_code_modification(code_files, modification_ask):
  new_code_files = []
  for file_code_pair in code_files:
    mod_prompt = prompt.get_modification_prompt("\n".join(file_code_pair["code_block"].split("\n")[1:]), modification_ask)
    modification_result = generate(mod_prompt)
    print("MOD_RESULT:", modification_result)
    if "RETURNEDCODE" in modification_result:
      modification_result = modification_result[modification_result.index("[/INST]"):]
      code_block_raw_string = modification_result[modification_result.index("RETURNEDCODE") + len("RETURNEDCODE"):]
      file_code_pair["code_block"] = re.findall(r"```(.*?)```", code_block_raw_string, re.DOTALL)[0]
    new_code_files.append(file_code_pair)
  return new_code_files

# this function takes a list of code files and generates a new package.json file if any dependencies are missing
# returns the new package.json file as a string
def resolve_missing_dependencies(code_files):
  print("Resolving missing dependencies...")
  codebase = "\n".join(
    list(map(lambda x: f"FILENAME: {x['file_name']}\nSOURCE: {x['code_block']}\n", code_files))
  )
  dep_prompt = prompt.get_dependency_prompt(codebase)
  dep_result = generate(dep_prompt)
  dep_result = dep_result[dep_result.index("[/INST]"):]
  print(dep_result)
  if "PACKAGEJSON" in dep_result:
    package_json_text = re.findall(r"```(.*?)```", dep_result, re.DOTALL)[0]
    return package_json_text
  else:
    return None

# this function takes a list of code files and a modification prompt and generates a new code block for each file using the prompt
def dev_loop(code_files, user_ask, modification_ask=None):
  if modification_ask:
    # update each related code block with a prediction using the modification ask of the user
    code_files = initiate_code_modification(code_files, modification_ask)

  # dependency resolving
  new_package_json = resolve_missing_dependencies(code_files)
  # set new package.json if it exists
  if new_package_json:
    for code_file in code_files:
      if 'package.json' in code_file["file_name"]:
        code_file["code_block"] = new_package_json
  # loop through each file and write the code to a file in the react-output directory
  for file_code_pair in code_files:
    filepath = "react-output/" + file_code_pair["file_name"]
    os.makedirs(os.path.dirname(filepath), exist_ok=True)
    with open(filepath, "w+") as f:
      # remove the first line of the code block and write the rest to the file
      code_block = file_code_pair["code_block"].split("\n")[1:]
      f.write("\n".join(code_block).encode('ascii', 'ignore').decode('ascii'))
  # ask the user if they want to make modifications to the generated code
  print("Done! Check out your codebase in react-output/")
  user_input = input("$ Do you wish to make modifications? [y/n]")
  if user_input == "y":
    modification_ask = input("$ What modifications do you want to make?")
    dev_loop(code_files, user_ask, modification_ask=modification_ask)
  else:
    print("Congrats on your 10x React project")

def main():
  print("$ I am your personal 10x React Engineer ask me what you want to build?")
  init_user_ask = input("$ ")
  initial_sum_prompt = prompt.get_summarization_prompt(init_user_ask)
  summarization_result = generate(initial_sum_prompt)
  # print(summarization_result)
  project_summary = parse_summarization_result(summarization_result)
  print("Parsed Summary:", project_summary)
  print("\n\nBeginning scaffolding...\n\n")
  scaffolding_output = prompt.get_code_writer_prompt(project_summary)
  scaffolding_result = generate(scaffolding_output)
  print(scaffolding_result)
  code_files = parse_scaffolding_result(scaffolding_result)

  dev_loop(code_files, init_user_ask)

main()

# TODO
# - main thing is to fine tune 13b llama to be better at react
# - JSON fixer for package.json
# - add generated codebase as context to modification inferences
# - add option to modify everything vs file by file
# - make summarization optional

!zip -r react-output.zip react-output

!rm -rf react-output react-output.zip